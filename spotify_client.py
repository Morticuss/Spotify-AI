import spotipy
from spotipy.oauth2 import SpotifyOAuth, SpotifyClientCredentials
import os
from typing import Optional, Dict, List
import time
from dotenv import load_dotenv
import random

load_dotenv()


class SpotifyClient:
    PLAYLIST_NAME = "AI Music Discovery - Top Picks"

    def __init__(self):
        self.scope = (
            "user-read-currently-playing "
            "user-read-playback-state "
            "user-modify-playback-state "
            "playlist-modify-public "
            "playlist-modify-private "
            "playlist-read-private"
        )

        client_id = os.getenv("SPOTIFY_CLIENT_ID")
        client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")

        if not client_id or not client_secret:
            raise ValueError(
                "Spotify credentials not found. "
                "Create a .env file with SPOTIFY_CLIENT_ID and SPOTIFY_CLIENT_SECRET"
            )

        self.client = spotipy.Spotify(auth_manager=SpotifyOAuth(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri="http://127.0.0.1:8080/callback",
            scope=self.scope,
            cache_path=".spotify_cache",
            open_browser=True,
            show_dialog=False
        ))

        try:
            self._app_client = spotipy.Spotify(auth_manager=SpotifyClientCredentials(
                client_id=client_id,
                client_secret=client_secret
            ))
            self._app_auth = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
        except Exception:
            self._app_client = self.client
            self._app_auth = None

        import requests as req_lib
        self._requests = req_lib

        self._feature_cache = {}
        self._track_cache = {}
        self._artist_genre_cache = {}
        self._user_id = None
        self._playlist_id = None

    def _get_user_id(self) -> str:
        if self._user_id is None:
            self._user_id = self.client.me()['id']
        return self._user_id

    def _find_existing_playlist(self) -> Optional[str]:
        if self._playlist_id:
            return self._playlist_id

        user_id = self._get_user_id()
        offset = 0
        while True:
            playlists = self.client.user_playlists(user_id, limit=50, offset=offset)
            if not playlists['items']:
                break
            for playlist in playlists['items']:
                if playlist['name'] == self.PLAYLIST_NAME and playlist['owner']['id'] == user_id:
                    self._playlist_id = playlist['id']
                    return self._playlist_id
            if not playlists['next']:
                break
            offset += 50
        return None

    def update_playlist(self, track_uris: List[str]) -> Dict:
        if not track_uris:
            return {'success': False, 'error': 'No tracks to add'}

        try:
            playlist_id = self._find_existing_playlist()

            if playlist_id is None:
                user_id = self._get_user_id()
                playlist = self.client.user_playlist_create(
                    user_id,
                    self.PLAYLIST_NAME,
                    public=False,
                    description="Auto-generated by AI Music Discovery. Updated with your top predicted tracks."
                )
                playlist_id = playlist['id']
                self._playlist_id = playlist_id

            valid_uris = [uri for uri in track_uris[:25] if uri and uri.startswith('spotify:track:')]

            if not valid_uris:
                return {'success': False, 'error': 'No valid track URIs'}

            self.client.playlist_replace_items(playlist_id, valid_uris)

            return {
                'success': True,
                'playlist_id': playlist_id,
                'track_count': len(valid_uris),
                'url': f"https://open.spotify.com/playlist/{playlist_id}"
            }
        except Exception as exception:
            print(f"Error updating playlist: {exception}")
            return {'success': False, 'error': str(exception)}

    def _batch_fetch_artist_genres(self, artist_ids: List[str]) -> Dict[str, List[str]]:
        uncached = [aid for aid in artist_ids if aid and aid not in self._artist_genre_cache]
        unique_uncached = list(dict.fromkeys(uncached))

        for i in range(0, len(unique_uncached), 50):
            batch = unique_uncached[i:i + 50]
            try:
                try:
                    artist_results = self._app_client.artists(batch)
                except Exception:
                    artist_results = self.client.artists(batch)

                if artist_results and artist_results.get('artists'):
                    for artist_info in artist_results['artists']:
                        if artist_info and artist_info.get('id'):
                            self._artist_genre_cache[artist_info['id']] = artist_info.get('genres', [])
            except Exception as e:
                print(f"Error batch fetching artist genres: {e}")
                for aid in batch:
                    if aid not in self._artist_genre_cache:
                        self._artist_genre_cache[aid] = []

        return {aid: self._artist_genre_cache.get(aid, []) for aid in artist_ids if aid}

    def _batch_fetch_tracks(self, track_ids: List[str]) -> Dict[str, Dict]:
        results = {}
        unique_ids = list(dict.fromkeys(track_ids))

        for i in range(0, len(unique_ids), 50):
            batch = unique_ids[i:i + 50]
            try:
                try:
                    tracks_response = self._app_client.tracks(batch)
                except Exception:
                    tracks_response = self.client.tracks(batch)

                if tracks_response and tracks_response.get('tracks'):
                    for track_info in tracks_response['tracks']:
                        if track_info and track_info.get('id'):
                            results[track_info['id']] = track_info
            except Exception as e:
                print(f"Error batch fetching tracks: {e}")

        return results

    def _build_feature_result(self, track_id, features, artist_id, genres):
        if features:
            return {
                'id': track_id,
                'danceability': features['danceability'],
                'energy': features['energy'],
                'valence': features['valence'],
                'tempo': features['tempo'] / 200.0,
                'acousticness': features['acousticness'],
                'instrumentalness': features['instrumentalness'],
                'speechiness': features['speechiness'],
                'liveness': features['liveness'],
                'loudness': (features['loudness'] + 60) / 60.0,
                'genres': genres,
                'artist_id': artist_id,
                'fallback': False
            }
        return {
            'id': track_id,
            'danceability': 0.5,
            'energy': 0.5,
            'valence': 0.5,
            'tempo': 0.5,
            'acousticness': 0.5,
            'instrumentalness': 0.0,
            'speechiness': 0.5,
            'liveness': 0.5,
            'loudness': 0.5,
            'genres': genres,
            'artist_id': artist_id,
            'fallback': True
        }

    def get_current_track(self) -> Optional[Dict]:
        try:
            current = self.client.current_playback()
            if current and current['is_playing']:
                track = current['item']
                track_data = {
                    'id': track['id'],
                    'name': track['name'],
                    'artist': ', '.join([artist['name'] for artist in track['artists']]),
                    'album_cover': track['album']['images'][0]['url'] if track['album']['images'] else None,
                    'uri': track['uri'],
                    'duration_ms': track['duration_ms'],
                    'progress_ms': current['progress_ms']
                }
                self._track_cache[track['id']] = track_data
                return track_data
            return None
        except Exception as exception:
            print(f"Error fetching current track: {exception}")
            return None

    def get_track_features(self, track_id: str) -> Optional[Dict]:
        if track_id in self._feature_cache:
            return self._feature_cache[track_id]

        result = self.get_batch_track_features([track_id])
        return result.get(track_id)

    def get_batch_track_features(self, track_ids: List[str]) -> Dict[str, Optional[Dict]]:
        results = {}
        uncached_ids = []

        for track_id in track_ids:
            if track_id in self._feature_cache:
                results[track_id] = self._feature_cache[track_id]
            else:
                uncached_ids.append(track_id)

        if not uncached_ids:
            return results

        unique_uncached = list(dict.fromkeys(uncached_ids))

        features_by_id = {}
        for i in range(0, len(unique_uncached), 100):
            batch = unique_uncached[i:i + 100]
            if self._app_auth is not None:
                try:
                    token = self._app_auth.get_access_token()
                    headers = {"Authorization": f"Bearer {token}"}
                    url = "https://api.spotify.com/v1/audio-features"
                    params = {"ids": ','.join(batch)}
                    resp = self._requests.get(url, headers=headers, params=params, timeout=15)
                    if resp.status_code == 200:
                        feature_list = resp.json().get('audio_features', [])
                        for tid, feat in zip(batch, feature_list):
                            if feat:
                                features_by_id[tid] = feat
                except Exception:
                    pass

        track_info_map = self._batch_fetch_tracks(unique_uncached)

        artist_ids_needed = []
        track_to_artist = {}
        for track_id in unique_uncached:
            track_info = track_info_map.get(track_id)
            if track_info and track_info.get('artists') and track_info['artists']:
                artist_id = track_info['artists'][0]['id']
                track_to_artist[track_id] = artist_id
                if artist_id not in self._artist_genre_cache:
                    artist_ids_needed.append(artist_id)

        if artist_ids_needed:
            self._batch_fetch_artist_genres(artist_ids_needed)

        for track_id in unique_uncached:
            artist_id = track_to_artist.get(track_id)
            genres = self._artist_genre_cache.get(artist_id, []) if artist_id else []
            features = features_by_id.get(track_id)

            result = self._build_feature_result(track_id, features, artist_id, genres)
            self._feature_cache[track_id] = result
            results[track_id] = result

        return results

    def fetch_genres_for_artist(self, artist_id: str) -> List[str]:
        if not artist_id:
            return []

        if artist_id in self._artist_genre_cache:
            return self._artist_genre_cache[artist_id]

        genre_map = self._batch_fetch_artist_genres([artist_id])
        return genre_map.get(artist_id, [])

    def search_random_track(self, query: str = "", limit: int = 50) -> Optional[Dict]:
        try:
            strategies = [
                self._search_by_letter_and_year,
                self._search_by_genre,
                self._search_by_decade,
                self._search_wildcard
            ]

            strategy = random.choice(strategies)
            track = strategy(limit)

            if track:
                return track

            return self._search_wildcard(limit)

        except Exception as exception:
            print(f"Error searching random track: {exception}")
            return None

    def _search_by_letter_and_year(self, limit: int) -> Optional[Dict]:
        random_char = random.choice('abcdefghijklmnopqrstuvwxyz')
        year_options = ['2024', '2023', '2022', '2021', '2020', '2019', '2018', '2015', '2010', '2005', '2000', '1995', '1990', '1985', '1980', '1975', '1970']
        year = random.choice(year_options)

        results = self.client.search(q=f"{random_char}% year:{year}", type='track', limit=limit)
        tracks = results['tracks']['items']

        if tracks:
            return self._format_track(random.choice(tracks))
        return None

    def _search_by_genre(self, limit: int) -> Optional[Dict]:
        genres = ['pop', 'rock', 'hip-hop', 'electronic', 'jazz', 'classical', 'country',
                 'r&b', 'indie', 'metal', 'folk', 'reggae', 'blues', 'soul', 'funk',
                 'alternative', 'punk', 'disco', 'house', 'techno', 'ambient']
        genre = random.choice(genres)

        results = self.client.search(q=f"genre:{genre}", type='track', limit=limit)
        tracks = results['tracks']['items']

        if tracks:
            return self._format_track(random.choice(tracks))
        return None

    def _search_by_decade(self, limit: int) -> Optional[Dict]:
        decades = ['2020-2024', '2010-2019', '2000-2009', '1990-1999', '1980-1989', '1970-1979']
        decade = random.choice(decades)

        results = self.client.search(q=f"year:{decade}", type='track', limit=limit)
        tracks = results['tracks']['items']

        if tracks:
            return self._format_track(random.choice(tracks))
        return None

    def _search_wildcard(self, limit: int) -> Optional[Dict]:
        random_char = random.choice('abcdefghijklmnopqrstuvwxyz')

        results = self.client.search(q=f"{random_char}%", type='track', limit=limit)
        tracks = results['tracks']['items']

        if tracks:
            return self._format_track(random.choice(tracks))
        return None

    def _format_track(self, track) -> Dict:
        track_data = {
            'id': track['id'],
            'name': track['name'],
            'artist': ', '.join([artist['name'] for artist in track['artists']]),
            'album_cover': track['album']['images'][0]['url'] if track['album']['images'] else None,
            'uri': track['uri']
        }
        self._track_cache[track['id']] = track_data
        return track_data

    def search_batch_random_tracks(self, count: int = 25) -> List[Dict]:
        tracks = []
        seen_ids = set()

        searches_needed = max(3, count // 15)

        for i in range(searches_needed):
            try:
                results = self.client.search(
                    q=self._get_diverse_query(i),
                    type='track',
                    limit=50
                )
                search_tracks = results['tracks']['items']

                if search_tracks:
                    for track in search_tracks:
                        if track['id'] not in seen_ids:
                            track_data = self._format_track(track)
                            tracks.append(track_data)
                            seen_ids.add(track['id'])

                            if len(tracks) >= count:
                                return tracks[:count]
            except Exception as e:
                print(f"Error in batch search {i}: {e}")
                continue

        return tracks

    def _get_diverse_query(self, index: int) -> str:
        strategies = [
            lambda: f"{random.choice('abcdefghijklmnopqrstuvwxyz')}% year:{random.choice(['2024', '2023', '2022', '2021', '2020', '2019', '2015', '2010', '2000', '1990'])}",
            lambda: f"genre:{random.choice(['pop', 'rock', 'hip-hop', 'electronic', 'jazz', 'indie', 'metal'])}",
            lambda: f"year:{random.choice(['2020-2024', '2010-2019', '2000-2009', '1990-1999'])}",
            lambda: f"{random.choice('abcdefghijklmnopqrstuvwxyz')}%"
        ]
        return strategies[index % len(strategies)]()

    def play_track(self, uri: str):
        try:
            devices = self.client.devices()
            if not devices['devices']:
                print("No active Spotify devices found. Please open Spotify on a device.")
                return

            self.client.start_playback(uris=[uri])
        except Exception as exception:
            print(f"Error playing track: {exception}")
            print("Make sure you have an active Spotify device (app open on phone/computer)")

    def clear_cache(self):
        self._feature_cache.clear()
        self._track_cache.clear()
        self._artist_genre_cache.clear()